using namespace __cblas, __linalg;

namespace __linalg;

/* substitute addition chains containing multiplications terms with
 the private function __linalg::sum

whenever a term in the summation is a simple multiplication - i.e
not a chain - the multiplication symbol ::* is replaced with the 
private symbol __linalg::*

whenever a term in the summation is a chain of multiplications the
private function __linalg::in_mul is used instead of __linalg::mul

all terms containing no multiplication are moved at the head of the 
tuple. */


def sum l ::+ a ::* b = sum(l,a * b);
def sum l1 ::+ mul l2 = sum(l1,in_mul l2);
def sum l ::+ a = sum (a,l);

def a ::* b ::+ c ::* d = sum (a * b,c * d);
def mul l ::+ a ::* b |
    a ::* b ::+ mul l = sum(a * b,in_mul l);
def mul l1 ::+ mul l2 = sum(in_mul l1,in_mul l2);

def a ::* b ::+ c |
    c ::+ a ::* b = sum (c,a * b);
def mul l ::+ c |
    c ::+ mul l = sum (c,in_mul l);

def sum (a ::+ b,rest) = sum(a,b,rest);


/* highest priority rules resolving a sum and a multiplication in 
the form

    C + A*B

these take advantage of temporary matrices flagged by __linalg::tmp, 
modifing them in place.*/

/* vector-matrix-vector */


sum (tmp y::dmatrix,A::dmatrix * x::dmatrix) = y
    if mx == 1 && my == 1 && nA == ny && mA == nx
    when
        nA, mA = dim A;
        nx, mx = dim x;
        ny, my = dim y;
        _ = cblas_dgemv CblasRowMajor CblasNoTrans mA nA 1.0 A nA x 1 1.0 y 1;
    end;
sum (tmp y::dmatrix,A::dmatrix^' * x::dmatrix) = y
    if mx == 1 && my == 1 && mA == ny && nA == nx
    when
        nA, mA = dim A;
        nx, mx = dim x;
        ny, my = dim y;
        _ = cblas_dgemv CblasRowMajor CblasTrans nA mA 1.0 A nA x 1 1.0 y 1;
    end;

sum (tmp y::dmatrix,A::dmatrix * x::dmatrix,rest) = sum (tmp y,rest)
    if mx == 1 && my == 1 && nA == ny && mA == nx
    when
        nA, mA = dim A;
        nx, mx = dim x;
        ny, my = dim y;
        _ = cblas_dgemv CblasRowMajor CblasNoTrans mA nA 1.0 A nA x 1 1.0 y 1;
    end;
sum (tmp y::dmatrix,A::dmatrix^' * x::dmatrix,rest) = sum (tmp y,rest)
    if mx == 1 && my == 1 && mA == ny && nA == nx
    when
        nA, mA = dim A;
        nx, mx = dim x;
        ny, my = dim y;
        _ = cblas_dgemv CblasRowMajor CblasTrans nA mA 1.0 A nA x 1 1.0 y 1;
    end;


/* vector-vector-matrix */

/* matrix-matrix-matrix */

// TO DO

/* wrong dimensions */


sum (tmp C::dmatrix,A::dmatrix   * B::dmatrix)        |
sum (tmp C::dmatrix,A::dmatrix^' * B::dmatrix)        |
sum (tmp C::dmatrix,A::dmatrix   * B::dmatrix^')      |
sum (tmp C::dmatrix,A::dmatrix^' * B::dmatrix^')      |
sum (tmp C::dmatrix,A::dmatrix   * B::dmatrix,rest)   |
sum (tmp C::dmatrix,A::dmatrix^' * B::dmatrix,rest)   |
sum (tmp C::dmatrix,A::dmatrix   * B::dmatrix^',rest) |
sum (tmp C::dmatrix,A::dmatrix^' * B::dmatrix^',rest) = throw dimensions_mismatch;


/* catch all rules that resolve into ::* and ::+ */

// TO DO


/* medium priority rules resolving a sum and a multiplication.

these combine multiplication and addition without modifing existing matrices,
the result is stored in a newly allocated matrix.*/

/* vector-matrix-vector */


sum (y::dmatrix,A::dmatrix * x::dmatrix) = out
    if mx == 1 && my == 1 && nA == ny && mA == nx
    when
        nA, mA = dim A;
        nx, mx = dim x;
        ny, my = dim y;
        out = pack y;
        _ = cblas_dgemv CblasRowMajor CblasNoTrans mA nA 1.0 A nA x 1 1.0 out 1;
    end;
sum (y::dmatrix,A::dmatrix^' * x::dmatrix) = out
    if mx == 1 && my == 1 && mA == ny && nA == nx
    when
        nA, mA = dim A;
        nx, mx = dim x;
        ny, my = dim y;
        out = pack y;
        _ = cblas_dgemv CblasRowMajor CblasTrans nA mA 1.0 A nA x 1 1.0 out 1;
    end;

sum (y::dmatrix,A::dmatrix * x::dmatrix,rest) = sum (tmp out,rest)
    if mx == 1 && my == 1 && nA == ny && mA == nx
    when
        nA, mA = dim A;
        nx, mx = dim x;
        ny, my = dim y;
        out = pack y;
        _ = cblas_dgemv CblasRowMajor CblasNoTrans nA mA 1.0 A nA x 1 1.0 out 1;
    end;
sum (y::dmatrix,A::dmatrix^' * x::dmatrix,rest) = sum (tmp out,rest)
    if mx == 1 && my == 1 && mA == ny && nA == nx
    when
        nA, mA = dim A;
        nx, mx = dim x;
        ny, my = dim y;
        out = pack y;
        _ = cblas_dgemv CblasRowMajor CblasTrans nA mA 1.0 A nA x 1 1.0 out 1;
    end;


/* vector-vector-matrix */

/* matrix-matrix-matrix */

// TO DO

/* wrong dimesnions */


sum (C::dmatrix,A::dmatrix   * B::dmatrix)        |
sum (C::dmatrix,A::dmatrix^' * B::dmatrix)        |
sum (C::dmatrix,A::dmatrix   * B::dmatrix^')      |
sum (C::dmatrix,A::dmatrix^' * B::dmatrix^')      |
sum (C::dmatrix,A::dmatrix   * B::dmatrix,rest)   |
sum (C::dmatrix,A::dmatrix^' * B::dmatrix,rest)   |
sum (C::dmatrix,A::dmatrix   * B::dmatrix^',rest) |
sum (C::dmatrix,A::dmatrix^' * B::dmatrix^',rest) = throw dimensions_mismatch;


/* catch all rules that resolve into ::* and ::+ */

// TO DO


/* least priority rules resolving a multiplication alone. */

/* matrix-vector */


sum (A::dmatrix * x::dmatrix,rest) = sum (tmp out,rest)
    if mx == 1 && mA == nx
    when
        nA, mA = dim A;
        nx, mx = dim x;
        out = double_matrix (nA,1) NULL;
        _ = cblas_dgemv CblasRowMajor CblasNoTrans mA nA 1.0 A nA x 1 1.0 out 1;
    end;
sum (A::dmatrix^' * x::dmatrix,rest) = sum (tmp out,rest)
    if mx == 1 && nA == nx
    when
        nA, mA = dim A;
        nx, mx = dim x;
        out = double_matrix (mA,1) NULL;
        _ = cblas_dgemv CblasRowMajor CblasTrans nA mA 1.0 A nA x 1 1.0 out 1;
    end;


/* vector-matrix */

/* matrix-matrix */

// TO DO

/* wrong dimensions */

sum (A::dmatrix   * B::dmatrix,rest)   |
sum (A::dmatrix^' * B::dmatrix,rest)   |
sum (A::dmatrix   * B::dmatrix^',rest) |
sum (A::dmatrix^' * B::dmatrix^',rest) = throw dimensions_mismatch;

/* catch all rules that resolve into ::* and ::+ */

// TO DO

namespace;